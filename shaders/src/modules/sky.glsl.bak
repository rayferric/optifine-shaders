#ifndef SKY_GLSL
#define SKY_GLSL

#include "/src/modules/constants.glsl"
#include "/src/modules/curve.glsl"
#include "/src/modules/hash.glsl"
#include "/src/modules/henyey_greenstein.glsl"
#include "/src/modules/intersection.glsl"
#include "/src/modules/luminance.glsl"

// dimensions of the physical system
#define SKY_PLANET_RADIUS     6371e3
#define SKY_ATMOSPHERE_HEIGHT 100e3
#define SKY_VIEW_HEIGHT       2.0

// density parameters
// At what height the density of Rayleigh and Mie particles is 1/euler's number?
#define SKY_RAYLEIGH_HEIGHT  8e3
#define SKY_MIE_HEIGHT       1.2e3
#define SKY_OZONE_PEAK_LEVEL 30e3
#define SKY_OZONE_FALLOFF    3e3

// probabilities of in/out-scattering each RGB wavelength of light for every
// type of molecule
#define SKY_RAYLEIGH_PROB vec3(3.8e-6, 13.5e-6, 33.1e-6)
#define SKY_MIE_PROB      vec3(21e-6)
// This is the probability of absorption which is similar to out-scattering.
#define SKY_OZONE_PROB    vec3(2.04e-5, 4.97e-5, 1.95e-6)

// Henyey Greenstein phase coefficient
#define SKY_G -0.8

// integration accuracy
#define SKY_SKY_SAMPLES   4
#define SKY_LIGHT_SAMPLES 1
// Set to more than 1 for a realistic, less vibrant sunset. Might not work well
// with artistic patches.

// luminance factors
#define SKY_SUN_LUMINANCE   5.0
#define SKY_MOON_LUMINANCE  0.05
#define SKY_STARS_LUMINANCE 0.002

// artistic parameters
#define SKY_ZENITH_PATCH_COLOR SKY_RAYLEIGH_PROB * 1000.0

// // RGB color + blackbody Y stop position in [-1, 1]
// // clang-format off
// #define SKY_AVG_GRADIENT_SIZE 6
// const vec4[SKY_AVG_GRADIENT_SIZE] SKY_AVG_GRADIENT =
// vec4[SKY_AVG_GRADIENT_SIZE]( 	vec4(mix(SKY_RAYLEIGH_PROB, vec3(10e-6),
// 0.2), -1.0), 	vec4(mix(SKY_RAYLEIGH_PROB, vec3(10e-6), 0.2), -0.275),
// 	vec4(mix(SKY_RAYLEIGH_PROB, vec3(10e-6), 0.2) * 4.0, -0.22),
// 	// vec4(mix(SKY_RAYLEIGH_PROB, vec3(10e-6), 0.2) * 10.0, -0.21),
// 	vec4(mix(SKY_RAYLEIGH_PROB, vec3(10e-6, 0.0, 0.0), 0.7) * 400.0, -0.1),
// 	vec4(mix(SKY_RAYLEIGH_PROB, vec3(10e-6), 0.2) * 600.0, -0.05),
// 	vec4(mix(SKY_RAYLEIGH_PROB, vec3(10e-6), 0.2) * 1000.0, 0.5)
// );
// // clang-format on

// // RGB color + blackbody Y stop position in [-1, 1]
// // clang-format off
// #define SKY_BLACKBODY_GRADIENT_SIZE 3
// const vec4[SKY_BLACKBODY_GRADIENT_SIZE] SKY_BLACKBODY_GRADIENT =
// vec4[SKY_BLACKBODY_GRADIENT_SIZE]( 	vec4(0.0), 	vec4(0.0), 	vec4(0.0)
// );
// // clang-format on

/**
 * @brief Approximates density values for a given point around the planet.
 *
 * @param pos position of the point, for which densities are calculated
 *
 * @return densities (between 0 and 1)
 * .x - density of Rayleigh-type particles
 * .y - density of Mie-type particles
 * .z - density of ozone particles
 */
vec3 avgDensities(in vec3 pos) {
	// height above surface
	float height = length(pos) - SKY_PLANET_RADIUS;

	vec3 densities;

	// abs(height) ensures that atmosphere is not infinitely dense inside of the
	// planet. This aids the black horizon issue.
	densities.x = exp(-abs(height) / SKY_RAYLEIGH_HEIGHT);
	densities.y = exp(-abs(height) / SKY_MIE_HEIGHT);
	densities.z =
	    (1.0 / cosh((SKY_OZONE_PEAK_LEVEL - height) / SKY_OZONE_FALLOFF)) *
	    densities.x;
	// (Ozone density scales similarly to rayleigh.)

	return densities;
}

/**
 * @brief Phase function used for Rayleigh scattering.
 *
 * @param cosTheta cosine of the angle between light vector and view
 direction
 *
 * @return Rayleigh phase function value
 */
float phaseRayleigh(in float cosTheta) {
	return (1.0 + cosTheta * cosTheta) * (3.0 / (16.0 * PI));
}

/**
 * @brief Calculates atmospheric scattering value for a ray intersecting the
 * planet. This function is used to calculate the sky color or trace
 volumetric
 * fog.
 *
 * @param viewDir normalized view direction in world space
 * @param lightDir normalized light vector in world space
 *
 * @return sky color
 */
vec3 atmosphere(in vec3 viewDir, in vec3 lightDir, in vec3 background) {
	// (All of the simulation is done is world space)

	// Find a hypothetical position of the observer on the surface of the planet
	vec3 eyePos = vec3(0.0, SKY_PLANET_RADIUS + SKY_VIEW_HEIGHT, 0.0);

	// Intersect the eye-sun ray with the atmosphere.
	Intersection intersection = intersectSphere(
	    eyePos, viewDir, SKY_PLANET_RADIUS + SKY_ATMOSPHERE_HEIGHT
	);

	// This "artistic" clamp vastly improves the quality of the sunset.
	// Additionally, it prevents the black horizon effect.
	// float maxLen     = 1e5 * (1.0 - abs(viewDir.y) * 0.9);
	// float maxLen     = 1e5 / bellCurve(viewDir.y);
	// intersection.far = min(intersection.far, maxLen);
	// float maxLen     = SKY_ATMOSPHERE_HEIGHT;
	// maxLen           *= (1.0 - abs(viewDir.y) * 0.5);
	// intersection.far = min(intersection.far, maxLen);

	// Check if the ray intersects the atmosphere.
	// if (intersection.far < intersection.near) {
	// 	return background;
	// }

	// Initialize the ray marching position.
	float rayPos = max(0.0, intersection.near);

	// Calculate the step size. (far - traceStart = far = traceDistance)
	float stepSize = (intersection.far - rayPos) / float(SKY_SKY_SAMPLES);

	// the starting 1D position along the marched ray
	// Always sample at the center of the step for temporal stability.
	rayPos += stepSize * 0.5;
	// rayPos += stepSize * hash(viewDir * frameTimeCounter).x;

	// the optical depth along the primary ray
	vec3 viewOpticalDepth = vec3(0.0);

	// We will accumulate the scattering values along the main ray.
	vec3 scatteredRayleigh = vec3(0.0);
	vec3 scatteredMie      = vec3(0.0);

	// mean(in_scattered_light_fraction * path_density) * |ray_end - ray_start|
	// = integrate(light_fraction(trace_distance) *
	// d(optical_depth(trace_distance)), ray_start, ray_end)
	for (int i = 0; i < SKY_SKY_SAMPLES; i++) {
		// three-dimensional marching position
		vec3 samplePos = eyePos + viewDir * rayPos;
		rayPos         += stepSize;

		// We will need the delta separately
		vec3 opticalDepthDelta = avgDensities(samplePos) * stepSize;
		viewOpticalDepth       += opticalDepthDelta;

		// Start marching the light ray.

		// Intersect the secondary ray to know how far to march.
		Intersection lightIntersection = intersectSphere(
		    samplePos, lightDir, SKY_PLANET_RADIUS + SKY_ATMOSPHERE_HEIGHT
		);
		// Again, we're intersecting from within the atmosphere, so hit will
		// always be found.

		// Calculate the step size. (far - marchStart (= 0) = far =
		// marchDistance)
		float lightStepSize = lightIntersection.far / float(SKY_LIGHT_SAMPLES);

		// Always sample at the center of the step for temporal stability.
		float lightRayPos = lightStepSize * 0.5;
		// float lightRayPos = lightStepSize * hash(viewDir *
		// frameTimeCounter).y;

		// the optical depth along the whole secondary ray
		vec3 lightOpticalDepth = vec3(0.0);

		// light ray optical depth =
		// integrate(density * d(step_size), ray_start, ray_end)
		for (int j = 0; j < SKY_LIGHT_SAMPLES; j++) {
			vec3 lightSamplePos = samplePos + lightDir * lightRayPos;
			lightRayPos         += lightStepSize;

			lightOpticalDepth += avgDensities(lightSamplePos) * lightStepSize;
		}

		// The light ray is now traced. We can calculate the fraction of light
		// that was out-scattered along the way.

		// What fraction of light survived out-scattering caused by all three
		// types of molecules along the whole path from eye to the marching
		// point and from there to the sun? This is analogic to absorption and
		// this can be modeled using Beer's law. Ozone actually absorbs the
		// light without emitting it again, but, again, both phenomena can be
		// modeled in the same way:
		//
		// optical depth = travel distance * density
		// total optical depth = ray optical depth + light optical depth
		// absorbance = absorption probability * total optical depth
		// light fraction = exp(-absorbance)
		//
		vec3 lightAfterOutScattering = exp(
		    -(SKY_RAYLEIGH_PROB * (viewOpticalDepth.x + lightOpticalDepth.x) +
		      SKY_MIE_PROB * (viewOpticalDepth.y + lightOpticalDepth.y) +
		      SKY_OZONE_PROB * (viewOpticalDepth.z + lightOpticalDepth.z))
		);

		// scatteredRayleigh and scatteredMie are actually half-products needed
		// for optimization, specifically:
		// mean in-scattered light fraction * mean optical depth
		// Look up the integral at the top of this block.
		scatteredRayleigh += lightAfterOutScattering * opticalDepthDelta.x;
		scatteredMie      += lightAfterOutScattering * opticalDepthDelta.y;
		// Ozone does not scatter light towards the camera but fully absorbs it
		// instead. That's why we don't need to add it to the scattered light.
	}

	// The final form of the equation is:
	// in-scattered light fraction =
	// in-scattered light fraction * optical depth *
	// scattering probability * phase function
	float cosTheta = dot(viewDir, lightDir);
	vec3  rayleigh =
	    scatteredRayleigh * SKY_RAYLEIGH_PROB * phaseRayleigh(cosTheta);
	vec3 mie =
	    scatteredMie * SKY_MIE_PROB * phaseHenyeyGreenstein(cosTheta, SKY_G);

	vec3 backgroundVisibility = exp(
	    -((SKY_RAYLEIGH_PROB * viewOpticalDepth.x) +
	      (SKY_MIE_PROB * viewOpticalDepth.y) +
	      (SKY_OZONE_PROB * viewOpticalDepth.z))
	);

	return rayleigh + mie + backgroundVisibility * background;
}

vec3 rot3D(vec3 vec, vec3 axis, float angle) {
	// build a quaternion
	vec3  xyz = axis * sin(angle / 2.0);
	float w   = cos(angle / 2.0);

	// quaternion * vector
	vec3 t = 2.0 * cross(xyz, vec);
	return vec + t * w + cross(xyz, t);
}

vec3 stars(in vec3 viewDir, float quantity) {
	vec3 origin = floor(viewDir * quantity);
	vec3 offset = hash(origin);
	vec3 dir    = normalize(origin + offset);
	vec3 color  = mix(offset, vec3(1.0), 0.8);

	// Modulate size of stars. Here we treat offset.x as a random number.
	float edge = mix(0.999995, 0.999998, offset.x);

	// offset.y > 0.5 removes every second star from the dome.
	return offset.y > 0.5
	         ? vec3(0.0)
	         : smoothstep(edge, edge + 0.000003, dot(viewDir, dir)) * color;
}

vec3 patchedAtmosphere(in vec3 viewDir, in vec3 lightDir, bool blackbody) {
	// Bend down the horizon on the other side of the sky.
	vec3 fakeViewDir = viewDir;
	fakeViewDir.y    += pow(dot(viewDir, -lightDir) * 0.5 + 0.5, 1.0) * 0.3;
	fakeViewDir      = normalize(fakeViewDir);

	// Slow down the sun at the horizon to make sunsets look better and last
	// longer.
	vec3 fakeLightDir = lightDir;

	// Sunsets look best at Y = 0.01.
	fakeLightDir.y += 0.02;
	// Pull Y towards zero.
	fakeLightDir.y *= smoothstep(0.0, 0.5, abs(fakeLightDir.y));
	// Push Y back up.
	fakeLightDir.y -= 0.02;

	fakeLightDir = normalize(fakeLightDir);

	vec3 sky = vec3(0.0);

	// Draw the blackbody
	if (blackbody) {
		float sunShape  = smoothstep(0.9995, 0.9996, dot(viewDir, lightDir));
		float fadeShape = smoothstep(-0.1, 0.1, viewDir.y);
		sky             += vec3(sunShape * fadeShape);
	}

	// Simulate scattering
	sky = atmosphere(fakeViewDir, fakeLightDir, sky);

	// Boost the zenith color during the sunset.
	float sunsetFactor = bellCurve(10.0 * lightDir.y);
	float zenithShape =
	    pow(dot(viewDir, mix(vec3(0.0, 1.0, 0.0), -lightDir, 0.2)) * 0.5 + 0.5,
	        2.0);
	sky.xyz += SKY_ZENITH_PATCH_COLOR * zenithShape * sunsetFactor;

	return sky;
}

float simpleTonemap(in float value) {
	return 1.0 - exp(-1.5 * value);
}

#define FAKE_SKY_COLOR     vec3(0.0, 0.3, 0.8)
#define FAKE_ACCENT_COLOR  vec3(0.8, 1.0, 1.0)
#define FAKE_LIGHT_COLOR   vec3(0.8, 0.6, 0.05)
#define FAKE_HORIZON_COLOR vec3(1.0, 0.2, 0.1)
vec3 fakeAtmosphere(in vec3 viewDir, in vec3 lightDir) {
	// viewDir.y = abs(viewDir.y);
	// vec3 sky = atmosphere(viewDir, lightDir, vec3(0.0));

	// base sky color
	vec3 sky = FAKE_SKY_COLOR;

	// lighter gradient from the bottom
	float accentFactor = simpleTonemap(exp(-viewDir.y * 4.0));
	sky                = mix(sky, FAKE_ACCENT_COLOR, accentFactor);

	// sky luminance affected by sun visibility
	float skyLightnessFactor = smoothstep(-0.3, 0.2, lightDir.y);
	sky                      *= skyLightnessFactor;

	// sunlight fog
	float fogViewFactor = pow(dot(viewDir, lightDir) * 0.5 + 0.5, 5.0) * 0.5;
	float fogLightnessFactor = smoothstep(-0.2, 0.1, lightDir.y);
	vec3  fogColor =
	    mix(FAKE_LIGHT_COLOR, FAKE_ACCENT_COLOR, fogLightnessFactor);
	sky = mix(sky, fogColor, fogViewFactor);

	// desaturation of the sky+accent color
	float desaturationFactor = simpleTonemap(exp(-lightDir.y * 10.0) * 0.25);
	sky = mix(sky, vec3(luminance(sky)), desaturationFactor);

	// sunlight tint
	float lightTimeFactor = 1.0 - smoothstep(0.2, 0.5, lightDir.y);
	float lightViewFactor = simpleTonemap(exp(-viewDir.y * 10.0));
	sky = mix(sky, FAKE_LIGHT_COLOR, lightViewFactor * lightTimeFactor);

	// horizon color
	float horizonViewFactor = simpleTonemap(exp(-viewDir.y * 20.0) * 0.2);
	sky = mix(sky, FAKE_HORIZON_COLOR, horizonViewFactor * lightTimeFactor);

	// second sky luminance pass to dim the sunset light
	float sunlightLightnessFactor = smoothstep(-0.3, 0.0, lightDir.y);
	sky                           *= sunlightLightnessFactor;

	// planet shadow
	float shadowNormalTrackFactor = smoothstep(-0.1, -0.3, lightDir.y);
	vec3  shadowNormal            = normalize(
        mix(vec3(0.0, 1.0, 0.0), lightDir, shadowNormalTrackFactor * 2.0)
    );
	float lowestVisibilityDot = shadowNormalTrackFactor * 2.0 - 1.0;
	// float visibilityFactor    = smoothstep(
	//     lowestVisibilityDot - 1.0,
	//     lowestVisibilityDot,
	//     dot(shadowNormal, viewDir)
	// );
	float visibilityFactor =
	    sCurve((dot(shadowNormal, viewDir) - lowestVisibilityDot) * 5.0);
	sky *= visibilityFactor;

	// Debug: draw blackbodies
	float sunShape = smoothstep(0.9995, 0.9998, dot(viewDir, lightDir));
	sky            = max(sky, vec3(sunShape) * 2.0);

	return vec3(sky);
}

vec3 sky(in vec3 viewDir, in vec3 sunDir) {
	// viewDir points into the camera, so let's reverse it.
	viewDir = -viewDir;

	vec3 sky = vec3(0.0);

	// sky += patchedAtmosphere(viewDir, sunDir, true) * SKY_SUN_LUMINANCE;
	// sky += patchedAtmosphere(viewDir, -sunDir, true) * SKY_MOON_LUMINANCE;
	sky += fakeAtmosphere(viewDir, sunDir);

	// One daylight cycle in Minecraft takes 20 minutes, so we need to do one
	// revolution per 20 minutes.
	sky += stars(
	           rot3D(
	               viewDir,
	               normalize(vec3(0.0, 0.2, -1.0)),
	               float(worldTime) / 24000.0 * -(2.0 * PI)
	           ),
	           11.0
	       ) *
	       SKY_STARS_LUMINANCE;

	return sky;
}

vec3 fog(in vec3 color, in vec3 worldPos, in vec3 lightDir) {
	// viewDir points into the camera, so let's reverse it.
	vec3  viewDir        = normalize(worldPos);
	vec3  bg             = fakeAtmosphere(viewDir, lightDir);
	float height         = worldPos.y + cameraPosition.y - 50.0;
	float heightFactor   = min(exp(-height * 0.05), 1.0);
	float distanceFactor = 1.0 - exp(-length(worldPos) * 0.002);
	return mix(color, bg, heightFactor * distanceFactor);
}

vec3 skyIndirect(in vec3 sunDir) {
	// vec3 sky = vec3(0.0);

	// sky += patchedAtmosphere(vec3(0.0, 1.0, 0.0), sunDir, false) *
	//        SKY_SUN_LUMINANCE;
	// sky += patchedAtmosphere(vec3(0.0, 1.0, 0.0), -sunDir, false) *
	//        SKY_MOON_LUMINANCE;

	// float sunsetFactor = bellCurve(5.0 * sunDir.y);
	// return sky * mix(1.5, 0.75, sunsetFactor);
	// return vec3(0.8, 0.8, 1.2);
	return fakeAtmosphere(normalize(vec3(1.0, 1.0, 1.0)), sunDir);
}

vec3 skyDirect(in vec3 lightDir, bool sun) {
	// return atmosphere(lightDir, lightDir, vec3(1.0)) *
	//        (sun ? SKY_SUN_LUMINANCE : SKY_MOON_LUMINANCE);
	return vec3(9.0, 9.0, 7.0);
}

#endif // SKY_GLSL
